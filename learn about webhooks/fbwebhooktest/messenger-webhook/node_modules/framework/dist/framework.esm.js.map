{"version":3,"file":"framework.esm.js","sources":["../src/hatch.ts","../src/app.ts","../src/navigation.ts","../src/contract/index.ts","../src/default-domain.ts","../src/index.ts"],"sourcesContent":["import * as React from 'react';\nimport { Domain, Event, Store, combine } from 'effector';\nimport { MatchedRoute } from 'react-router-config';\n\nimport { defaultDomain } from './default-domain';\n\nconst HATCH = 'framework/page-hatch';\n\nexport interface HatchParams {\n  params: Record<string, string>;\n  query: Record<string, string>;\n}\n\n/**\n * Hatch is like a Gate, but just for models\n */\nexport interface Hatch {\n  // Called by history from withHatch\n  enter: Event<HatchParams>;\n  update: Event<HatchParams>;\n  exit: Event<void>;\n\n  $opened: Store<boolean>;\n  $params: Store<Record<string, string>>;\n  $query: Store<Record<string, string>>;\n\n  $props: Store<HatchParams>;\n}\n\n/**\n * Events here is an input signal, history should call them when route enters, updates, and exits.\n * Stores is derived from this events and holds specific parameters\n * `$opened` holds current state of page, if user visited page but not left, it is `true`\n */\nexport function createHatch(domain: Domain = defaultDomain): Hatch {\n  const $opened = domain.createStore(false);\n  const $params = domain.createStore<Record<string, string>>({});\n  const $query = domain.createStore<Record<string, string>>({});\n\n  const hatch = {\n    enter: domain.createEvent<HatchParams>(),\n    update: domain.createEvent<HatchParams>(),\n    exit: domain.createEvent<void>(),\n    $opened,\n    $params,\n    $query,\n    $props: combine({ params: $params, query: $query }),\n  };\n\n  $params.on([hatch.enter, hatch.update], (_, { params }) => params);\n  $query.on([hatch.enter, hatch.update], (_, { query }) => query);\n\n  hatch.$opened.on(hatch.enter, () => true).on(hatch.exit, () => false);\n  // Developer may want to read props when user leaves the page\n  // if $opened store will reset on hatch.exit, data will be deleted\n\n  return hatch;\n}\n\nexport function withHatch<C extends React.ComponentType>(hatch: Hatch, component: C): C {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  (component as any)[HATCH] = hatch;\n  return component;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function getHatch<T extends React.ComponentType<any>>(component: T): Hatch | undefined {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return (component as any)[HATCH];\n}\n\nexport function lookupHatch<P>(match: MatchedRoute<P>): Hatch | undefined {\n  if (match.route.component) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return getHatch(match.route.component as any);\n  }\n}\n","import { Domain, Event, combine, forward, guard } from 'effector';\nimport { RouteConfig, matchRoutes } from 'react-router-config';\nimport { splitMap } from 'patronum';\n\nimport { HatchParams, getHatch } from './hatch';\nimport { createNavigation } from './navigation';\nimport { defaultDomain } from './default-domain';\n\n// eslint-disable-next-line sonarjs/cognitive-complexity\nexport function createBrowserApplication(config: {\n  ready: Event<void>;\n  routes: RouteConfig[];\n  domain?: Domain;\n}) {\n  const domain = config.domain || defaultDomain;\n  const navigation = createNavigation(domain);\n  forward({ from: config.ready, to: navigation.historyEmitCurrent });\n\n  const routeResolved = navigation.historyChanged.filterMap((change) => {\n    const routes = matchRoutes(config.routes, change.pathname);\n\n    if (routes.length > 0) {\n      return {\n        ...routes[0],\n        change,\n      };\n    }\n  });\n\n  for (const { component, path } of config.routes) {\n    if (!component) return;\n    const { routeMatched, __: notMatched } = splitMap({\n      source: routeResolved,\n      cases: {\n        routeMatched: ({ route, match, change }) => {\n          if (route.path === path) {\n            return {\n              params: match.params, // /user/:userId -> /user/123 -> { userId: 123 }\n              query: Object.fromEntries(new URLSearchParams(change.search)),\n            };\n          }\n          return undefined;\n        },\n      },\n    });\n\n    const hatchEnter = domain.createEvent<HatchParams>();\n    const hatchUpdate = domain.createEvent<HatchParams>();\n    const hatchExit = domain.createEvent<void>();\n\n    // Triggered when hatch is used from the main bundle\n    const dontNeedLoadChunk = domain.createEvent();\n\n    const $chunkLoaded = domain.createStore(false);\n    const $hasHatch = domain.createStore(getHatch(component) !== undefined);\n\n    const loadPageFx = domain.createEffect(async () => {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const loader = (component as any).load;\n      if (typeof loader === 'function') {\n        const module = await loader();\n        if (!module.default) {\n          console.info(`Not found default export for \"${path}\" route`);\n          return null;\n        }\n        // eslint-disable-next-line @typescript-eslint/ban-types\n        return module.default as {};\n      }\n      return component;\n    });\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const setupHatchLinksFx = domain.createEffect((page: any) => {\n      const hatch = getHatch(page);\n      if (hatch) {\n        forward({ from: hatchEnter, to: hatch.enter });\n        forward({ from: hatchUpdate, to: hatch.update });\n        forward({ from: hatchExit, to: hatch.exit });\n        return true;\n      }\n      return false;\n    });\n\n    // Shows that user is on the route\n    const $onRoute = domain\n      .createStore(false)\n      .on(routeMatched, () => true)\n      .on(notMatched, () => false);\n\n    // Shows that user visited route and wait for page\n    // If true, page.hatch.enter is triggered and logic is ran\n    const $onPage = domain\n      .createStore(false)\n      .on(hatchEnter, () => true)\n      .on(hatchExit, () => false);\n\n    $chunkLoaded.on(loadPageFx.done, () => true).on(dontNeedLoadChunk, () => true);\n    $hasHatch.on(setupHatchLinksFx.doneData, (_, has) => has);\n\n    // When hatch not found on component from route and chunk don't load before\n    guard({\n      source: routeMatched,\n      filter: combine(\n        $hasHatch,\n        $chunkLoaded,\n        (hasHatch, chunkLoaded) => !hasHatch && !chunkLoaded,\n      ),\n      target: loadPageFx,\n    });\n\n    // After loading page chunk check that it has Page and try to connect with local events\n    guard({\n      source: loadPageFx.doneData,\n      filter: (value) => value !== null,\n      target: setupHatchLinksFx,\n    });\n\n    // Hatch found on component from route, but chunk never loaded\n    // We need to setup connections between hatch from component and local triggers\n    guard({\n      source: routeMatched,\n      filter: combine($hasHatch, $chunkLoaded, (hasHatch, chunkLoaded) => hasHatch && !chunkLoaded),\n      target: [setupHatchLinksFx.prepend(() => component), dontNeedLoadChunk],\n    });\n\n    // Trigger local unit only after loading chunk and setup connections\n    // Set onPage = true\n    guard({\n      source: routeMatched,\n      clock: setupHatchLinksFx.doneData,\n      filter: $onRoute,\n      target: hatchEnter,\n    });\n\n    guard({\n      source: routeMatched,\n      filter: $onPage,\n      target: hatchUpdate,\n    });\n\n    // onPage = false should set only after exit logic is run\n    guard({\n      source: notMatched,\n      filter: $onPage,\n      target: hatchExit,\n    });\n  }\n\n  return { navigation };\n}\n","import { Domain, sample } from 'effector';\nimport { createBrowserHistory } from 'history';\n\nexport interface HistoryChange {\n  pathname: string;\n  hash: string;\n  search: string;\n  action: 'PUSH' | 'POP' | 'REPLACE';\n}\n\nexport function createNavigation(domain: Domain) {\n  const history = typeof document !== 'undefined' ? createBrowserHistory() : null;\n\n  const historyPush = domain.createEffect<string, void>();\n  const historyPushSearch = domain.createEffect<string, void>();\n  const historyReplace = domain.createEffect<string, void>();\n\n  const historyChanged = domain.createEvent<HistoryChange>();\n\n  const historyEmitCurrent = domain.createEvent();\n\n  if (process.env.NODE_ENV !== 'test') {\n    historyPush.use((url) => history?.push(url));\n    historyReplace.use((url) => history?.replace(url));\n    historyPushSearch.use((search) => history?.push({ search }));\n\n    history?.listen(({ pathname, search, hash }, action) => {\n      historyChanged({ pathname, search, hash, action });\n    });\n\n    // do not actual change history, just trigger history changed with correct arguments\n    sample({\n      source: historyEmitCurrent,\n      fn: () =>\n        ({\n          action: 'REPLACE',\n          hash: history?.location.hash,\n          pathname: history?.location.pathname,\n          search: history?.location.search,\n        } as HistoryChange),\n      target: historyChanged,\n    });\n  }\n\n  return {\n    history,\n    historyPush,\n    historyPushSearch,\n    historyReplace,\n    historyChanged,\n    historyEmitCurrent,\n  };\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { Unit, is, forward } from 'effector';\n\ntype KeysOfEffectorApi<API> = {\n  [KEY in keyof API]: API[KEY] extends Unit<any> ? KEY : never;\n}[keyof API];\n\nexport function contract<\n  Properties extends string,\n  Page extends Record<Properties, unknown>\n>(config: { page: Page; model: Pick<Page, KeysOfEffectorApi<Page>> }) {\n  for (const name in config.page) {\n    const pageUnit = config.page[name];\n\n    // Workaround for typescript\n    // We're already proofed by type system that user should pass\n    // each property to model object for page API.\n    // Each property that don't implements Effector API must be excluded\n    const modelUnit = (config.model as Page)[name];\n\n    // Typically we can import page like this:\n    // import * as page from './page'\n    // And there will be React-component in the list of properties\n    // is.unit omit it\n    if (pageUnit && modelUnit && is.unit(pageUnit) && is.unit(modelUnit)) {\n      // Stores has an unique data flow: from model to page\n      // When store in the model is changed, we want to change the store in the page too\n      // But we don't want to change store from the page's code\n      if (is.store(pageUnit) && is.store(modelUnit)) {\n        forward({ from: modelUnit, to: pageUnit });\n\n        pageUnit.defaultState = modelUnit.defaultState;\n\n        // Change current state\n        (pageUnit as any).stateRef.current = (modelUnit as any).stateRef.current;\n\n        // Change initial state inside scope\n        // https://t.me/c/1489066599/4652\n        (pageUnit as any).stateRef.before = [\n          {\n            type: 'map',\n            fn: (state: unknown) => state,\n            from: (modelUnit as any).stateRef,\n          },\n        ];\n      }\n      // Typical data flow: from page to model\n      // When something happened in the page (event is triggered)\n      // We want to trigger the same event in the model to start our logic\n      // But model can trigger the event too\n      // Typically we don't want to subscribe to events in the page\n      else {\n        forward({ from: pageUnit, to: modelUnit });\n      }\n    }\n  }\n}\n","import { createDomain } from 'effector';\n\nexport const defaultDomain = createDomain('framework/default');\n","import loadable from '@loadable/component';\nimport { RouteConfig, renderRoutes } from 'react-router-config';\n\nexport { createBrowserApplication } from './app';\nexport { createHatch, getHatch, withHatch, lookupHatch } from './hatch';\nexport type { Hatch, HatchParams } from './hatch';\n\nexport { contract } from './contract';\n\nexport const createPages = (routes: RouteConfig[]) => renderRoutes(routes);\n\nexport { loadable };\nexport type { RouteConfig };\n"],"names":["createHatch","domain","defaultDomain","$opened","createStore","$params","$query","hatch","enter","createEvent","update","exit","$props","combine","params","query","on","_","withHatch","component","HATCH","getHatch","lookupHatch","match","route","createBrowserApplication","config","navigation","history","document","createBrowserHistory","historyPush","createEffect","historyPushSearch","historyReplace","historyChanged","historyEmitCurrent","process","env","NODE_ENV","use","url","push","replace","search","listen","pathname","hash","action","sample","source","fn","location","target","createNavigation","forward","from","ready","to","routeResolved","filterMap","change","routes","matchRoutes","length","path","routeMatched","__","notMatched","splitMap","cases","Object","fromEntries","URLSearchParams","hatchEnter","hatchUpdate","hatchExit","dontNeedLoadChunk","$chunkLoaded","$hasHatch","undefined","loadPageFx","async","loader","load","module","default","console","info","setupHatchLinksFx","page","$onRoute","$onPage","done","doneData","has","guard","filter","hasHatch","chunkLoaded","value","prepend","clock","contract","name","pageUnit","modelUnit","model","is","unit","store","defaultState","stateRef","current","before","type","state","createDomain","createPages","renderRoutes"],"mappings":"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"}